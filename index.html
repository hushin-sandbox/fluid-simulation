<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cyberpunk Fluid Simulation - Three.js</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: 'Courier New', monospace;
      }

      canvas {
        display: block;
      }

      .controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 10px;
        color: #00e5ff;
        border: 2px solid #00e5ff;
        box-shadow: 0 0 20px rgba(0, 229, 255, 0.5);
        width: 280px;
      }

      .controls h3 {
        margin: 0 0 15px 0;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 0 10px currentColor;
      }

      .control-group {
        margin: 10px 0;
      }

      .control-group label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #fff200;
        text-shadow: 0 0 5px currentColor;
      }

      .control-group input[type='range'] {
        width: 100%;
        -webkit-appearance: none;
        height: 5px;
        background: linear-gradient(90deg, #ff2ed1, #00e5ff, #00ff8c);
        outline: none;
        border-radius: 5px;
      }

      .control-group input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 15px;
        height: 15px;
        background: #fff200;
        cursor: pointer;
        border-radius: 50%;
        box-shadow: 0 0 10px #fff200;
      }

      button {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        background: linear-gradient(45deg, #ff2ed1, #3f48ff);
        border: none;
        color: white;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s;
        font-family: 'Courier New', monospace;
      }

      button:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(255, 46, 209, 0.5);
      }

      .info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #00ff8c;
        font-size: 14px;
        text-shadow: 0 0 10px currentColor;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #00ff8c;
      }

      .value-display {
        color: #ff8a00;
        float: right;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <h3>流体パラメータ</h3>

      <div class="control-group">
        <label
          >速度 <span class="value-display" id="speed-value">4</span></label
        >
        <input type="range" id="speed" min="1" max="10" step="0.5" value="4" />
      </div>

      <div class="control-group">
        <label
          >渦の強さ
          <span class="value-display" id="vortex-value">1.5</span></label
        >
        <input
          type="range"
          id="vortex"
          min="0.5"
          max="3"
          step="0.1"
          value="1.5"
        />
      </div>

      <div class="control-group">
        <label
          >カラー強度
          <span class="value-display" id="color-intensity-value"
            >1.5</span
          ></label
        >
        <input
          type="range"
          id="color-intensity"
          min="0.5"
          max="3"
          step="0.1"
          value="1.5"
        />
      </div>

      <div class="control-group">
        <label
          >自動注入速度
          <span class="value-display" id="auto-speed-value">50</span></label
        >
        <input
          type="range"
          id="auto-speed"
          min="10"
          max="100"
          step="10"
          value="50"
        />
      </div>

      <button id="reset">リセット</button>
      <button id="capture">画像を保存 (Sキー)</button>
      <div
        style="
          margin-top: 10px;
          font-size: 11px;
          color: #00ff8c;
          text-align: center;
        "
      >
        ※保存がうまくいかない場合は<br />右クリック→「画像を保存」でも可能
      </div>
    </div>

    <div class="info">
      自動流体シミュレーション実行中 | Sキーで画像保存<br />
      <span style="font-size: 12px; opacity: 0.8"
        >※保存できない場合は右クリック→「画像を保存」</span
      >
    </div>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

      let fluid,
        paint,
        count = 0,
        canvas;
      let params = {
        speed: 4,
        vortexStrength: 1.5,
        colorIntensity: 1.5,
        autoSpeed: 50,
        time: 0,
      };

      let autoForcePoints = [];

      // ノイズ関数を含むシェーダーコード
      const noise = `
        #define NORMALIZE_GRADIENTS
        #undef USE_CIRCLE
        #define COLLAPSE_SORTNET

        float permute(float x0,vec3 p) {
            float x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }
        vec2 permute(vec2 x0,vec3 p) {
            vec2 x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }
        vec3 permute(vec3 x0,vec3 p) {
            vec3 x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }
        vec4 permute(vec4 x0,vec3 p) {
            vec4 x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }

        const vec4 pParam = vec4( 17.0*17.0, 34.0, 1.0, 7.0);

        float taylorInvSqrt(float r) {
            return ( 0.83666002653408 + 0.7*0.85373472095314 - 0.85373472095314 * r );
        }

        float simplexNoise2(vec2 v) {
            const vec2 C = vec2(0.211324865405187134, 0.366025403784438597);
            const vec3 D = vec3( 0., 0.5, 2.0) * 3.14159265358979312;
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1  =  (x0.x > x0.y) ? vec2(1.,0.) : vec2(0.,1.) ;
            vec2 x1 = x0 - i1 + 1. * C.xx ;
            vec2 x2 = x0 - 1. + 2. * C.xx ;
            i = mod(i, pParam.x);
            vec3 p = permute( permute(
                i.y + vec3(0., i1.y, 1. ), pParam.xyz)
                + i.x + vec3(0., i1.x, 1. ), pParam.xyz);
            vec3 x = fract(p / pParam.w) ;
            vec3 h = 0.5 - abs(x) ;
            vec3 sx = vec3(lessThan(x,D.xxx)) *2. -1.;
            vec3 sh = vec3(lessThan(h,D.xxx));
            vec3 a0 = x + sx*sh;
            vec2 p0 = vec2(a0.x,h.x);
            vec2 p1 = vec2(a0.y,h.y);
            vec2 p2 = vec2(a0.z,h.z);
            p0 *= taylorInvSqrt(dot(p0,p0));
            p1 *= taylorInvSqrt(dot(p1,p1));
            p2 *= taylorInvSqrt(dot(p2,p2));
            vec3 g = 2.0 * vec3( dot(p0, x0), dot(p1, x1), dot(p2, x2) );
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.);
            m = m*m ;
            return 1.66666* 70.*dot(m*m, g);
        }

        float simplexNoise3(vec3 v) {
            const vec2  C = vec2(1./6. , 1./3. ) ;
            const vec4  D = vec4(0., 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 =   v - i + dot(i, C.xxx) ;
            vec3 g = vec3( greaterThan(   x0.xyz, x0.yzx) );
            vec3 l = vec3( lessThanEqual( x0.xyz, x0.yzx) );
            vec3 i1 = g.xyz  * l.zxy;
            vec3 i2 = max( g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + 1. * C.xxx;
            vec3 x2 = x0 - i2 + 2. * C.xxx;
            vec3 x3 = x0 - 1. + 3. * C.xxx;
            i = mod(i, pParam.x );
            vec4 p = permute( permute( permute(
                i.z + vec4(0., i1.z, i2.z, 1. ), pParam.xyz)
                + i.y + vec4(0., i1.y, i2.y, 1. ), pParam.xyz)
                + i.x + vec4(0., i1.x, i2.x, 1. ), pParam.xyz);
            float n_ = 1.0/pParam.w ;
            vec3  ns = n_ * D.wyz - D.xzx ;
            vec4 j = p - pParam.w*pParam.w*floor(p * ns.z *ns.z);
            vec4 x_ = floor(j * ns.z)  ;
            vec4 y_ = floor(j - pParam.w * x_ ) ;
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1. - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = vec4(lessThan(b0,D.xxxx)) *2. -1.;
            vec4 s1 = vec4(lessThan(b1,D.xxxx)) *2. -1.;
            vec4 sh = vec4(lessThan(h, D.xxxx));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            p0 *= taylorInvSqrt(dot(p0,p0));
            p1 *= taylorInvSqrt(dot(p1,p1));
            p2 *= taylorInvSqrt(dot(p2,p2));
            p3 *= taylorInvSqrt(dot(p3,p3));
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);
            m = m * m;
            return 48.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                dot(p2,x2), dot(p3,x3) ) );
        }

        float v3n1(vec3 v) {
            return simplexNoise3(v);
        }`;

      const vert = `
        varying vec2 vUv;
        varying vec3 vNormal;

        void main() {
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
        }`;

      const advectionFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        void main() {
            vec2 vel = texture2D(tex, wrap(vUv)).xy;
            vec4 color = texture2D(tex, wrap(vUv + vel * speed / res));
            gl_FragColor = color;
        }`;

      const divergenceFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        vec2 u(vec2 coord) {
            return texture2D(tex, wrap(coord)).xy;
        }

        void main() {
            float rho = 1.0;
            float deltaT = 1.0 / 60.0;
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;

            float divergence =
                (px.x * rho / deltaT) *
                (
                    (u(vUv - px.xz).x -
                    u(vUv + px.xz).x)
                    +
                    (u(vUv - px.zy).y -
                    u(vUv + px.zy).y)
                );

            gl_FragColor = vec4(divergence , 0.0, 0.0, 1.0);
        }`;

      const forceInitFrag =
        noise +
        `
        uniform float seed;
        uniform vec2 res;
        uniform float time;
        uniform float vortexStrength;
        varying vec2 vUv;
        varying vec3 vNormal;

        void main() {
            float n0 = seed + 12.3 + time * 0.01;
            float n1 = seed + 123.4 + time * 0.02;
            float n2 = seed + 1234.5 + time * 0.03;

            vec2 v0 = vUv * res / 1111.5;
            vec2 v1 = vUv * res / 1124.0;
            vec2 v2 = vUv * res / 1136.0;

            float nr = (v3n1(vec3(v0, n0)) + v3n1(vec3(v1, n1)) + v3n1(vec3(v2, n2))) * vortexStrength;
            float ng = (v3n1(vec3(v0, n1)) + v3n1(vec3(v1, n2)) + v3n1(vec3(v2, n0))) * vortexStrength;

            // 中心に向かう流れを追加
            vec2 center = vec2(0.5, 0.5);
            vec2 toCenter = (center - vUv) * 0.5;

            gl_FragColor = vec4(nr + toCenter.x, ng + toCenter.y, 0.0, 1.0);
        }`;

      const forceRenderFrag = `
        varying vec2 vUv;
        varying vec3 vNormal;
        uniform sampler2D tex;

        void main( void ) {
            vec4 vel = texture2D(tex, vUv);
            float magnitude = length(vel.xy);
            vec3 color = vec3(magnitude * 2.0, magnitude * 0.5, magnitude);
            gl_FragColor = vec4(color, 1.0);
        }`;

      const forceUpdateFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D pressure;
        uniform sampler2D advection;
        uniform vec2 forcePoint;
        uniform vec2 forceVector;
        uniform float time;

        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        float p(vec2 coord) {
            return texture2D(pressure, wrap(coord)).x;
        }

        void main() {
            float deltaT = 1.0 / 60.0;
            float rho = 0.999;
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;
            vec4 u_a = texture2D(advection, vUv);

            float diff_p_x = (p(vUv + px.xz) - p(vUv - px.xz));
            float u_x = u_a.x - deltaT / (2.0 * rho * px.x) * diff_p_x;
            float diff_p_y = (p(vUv + px.zy) - p(vUv - px.zy));
            float u_y = u_a.y - deltaT / (2.0 * rho * px.y) * diff_p_y;

            // 外部からの力を追加
            float dist = distance(vUv, forcePoint);
            float influence = exp(-dist * dist * 500.0);
            u_x += forceVector.x * influence;
            u_y += forceVector.y * influence;

            u_a = vec4(vec2(u_x, u_y) * 1.0, 0.0, 1.0);

            gl_FragColor = u_a;
        }`;

      const pressureFrag =
        noise +
        `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        uniform sampler2D divergence;

        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        float d(vec2 coord) {
            return texture2D(divergence, wrap(coord)).x;
        }

        float p(vec2 coord) {
            return texture2D(tex, wrap(coord)).x;
        }

        void main() {
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;

            float pressure = 0.25 * (d(vUv)
            + p(vUv + px.xz)
            + p(vUv - px.xz)
            + p(vUv + px.zy)
            + p(vUv - px.zy)
            );

            gl_FragColor = vec4(vec3(pressure), 1.0);
        }`;

      // サイバーパンク風のペイントシェーダー
      const paintInitFrag =
        noise +
        `
        uniform float seed;
        uniform vec2 res;
        uniform float time;
        varying vec2 vUv;
        varying vec3 vNormal;

        void main() {
            float n0 = seed + 12.3;
            float n1 = seed + 123.4;
            float n2 = seed + 1234.5;

            vec2 v0 = vUv * res / 1234.5;
            vec2 v1 = vUv * res / 2345.0;
            vec2 v2 = vUv * res / 3456.0;

            float nr = v3n1(vec3(v0, n0)) + v3n1(vec3(v1, n2)) + v3n1(vec3(v2, n1));
            float ng = v3n1(vec3(v1, n1)) + v3n1(vec3(v2, n0)) + v3n1(vec3(v0, n2));
            float nb = v3n1(vec3(v2, n2)) + v3n1(vec3(v0, n1)) + v3n1(vec3(v1, n0));

            // サイバーパンクカラー
            vec4 color;
            float zone = fract(vUv.x * 7.0 + time * 0.01);

            if (zone < 0.14) {
                color = vec4(0.0, 0.898, 1.0, 1.0); // シアン
            } else if (zone < 0.28) {
                color = vec4(1.0, 0.18, 0.82, 1.0); // マゼンタ
            } else if (zone < 0.42) {
                color = vec4(1.0, 0.541, 0.0, 1.0); // オレンジ
            } else if (zone < 0.57) {
                color = vec4(1.0, 0.949, 0.0, 1.0); // イエロー
            } else if (zone < 0.71) {
                color = vec4(0.0, 1.0, 0.549, 1.0); // ライムグリーン
            } else if (zone < 0.85) {
                color = vec4(0.627, 0.184, 1.0, 1.0); // バイオレット
            } else {
                color = vec4(0.247, 0.282, 1.0, 1.0); // エレクトリックブルー
            }

            color.rgb += vec3(nr, ng, nb) * 0.3;
            gl_FragColor = color;
        }`;

      const paintRenderFrag = `
        varying vec2 vUv;
        varying vec3 vNormal;
        uniform vec2 res;
        uniform sampler2D tex;
        uniform float colorIntensity;
        uniform float time;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        void main( void ) {
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0);
            vec4 pu = texture2D(tex, vUv);
            vec4 p = texture2D(tex, wrap(vUv + px.yz));

            vec4 color = p;
            color.r += (p.r - pu.r) * 0.5;
            color.g += (p.g - pu.g) * 0.5;
            color.b += (p.b - pu.b) * 0.5;

            // グロー効果
            color.rgb *= colorIntensity;

            // ブルーム効果を追加
            float brightness = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            if (brightness > 0.5) {
                color.rgb += color.rgb * pow(brightness, 2.0) * 0.3;
            }

            gl_FragColor = color;
        }`;

      const paintUpdateFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        uniform sampler2D velocity;

        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        void main() {
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;
            vec4 v = texture2D(velocity, vUv);
            vec4 p = texture2D(tex, wrap(vUv + px.xy * v.xy));

            // 色の拡散を少し追加
            p.rgb *= 0.999;

            gl_FragColor = p;
        }`;

      // Fluid クラス
      class Fluid {
        constructor(context) {
          this.context = context;
          this.speed = params.speed;
          this.forceInitMaterial = this.createShaderMaterial(forceInitFrag);
          this.divergenceMaterial = this.createShaderMaterial(divergenceFrag);
          this.advectionMaterial = this.createShaderMaterial(advectionFrag);
          this.pressureMaterial = this.createShaderMaterial(pressureFrag);
          this.updateMaterial = this.createShaderMaterial(forceUpdateFrag);
          this.renderMaterial = this.createShaderMaterial(forceRenderFrag);
          this.velocity = [
            this.createRenderTarget(),
            this.createRenderTarget(),
          ];
          this.pressure = [
            this.createRenderTarget(),
            this.createRenderTarget(),
          ];
          this.divergence = this.createRenderTarget();
          this.advection = this.createRenderTarget();
          this.blank = this.createRenderTarget();

          this.mainScene = new THREE.Scene();
          this.mainMesh = this.createMesh(
            0,
            0,
            this.context.width,
            this.context.height,
          );
          this.mainScene.add(this.mainMesh);

          this.init();
        }

        init() {
          this.velocityIndex = 0;
          this.context.renderer.setRenderTarget(this.velocity[0]);
          this.mainMesh.material = this.forceInitMaterial;
          this.forceInitMaterial.uniforms.seed = {
            value: Math.random() * 100.0,
          };
          this.forceInitMaterial.uniforms.time = { value: params.time };
          this.forceInitMaterial.uniforms.vortexStrength = {
            value: params.vortexStrength,
          };
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        createShaderMaterial(frag) {
          return new THREE.ShaderMaterial({
            vertexShader: vert,
            fragmentShader: frag,
            uniforms: {
              tex: { value: null },
              res: { value: [this.context.width, this.context.height] },
              speed: { value: this.speed },
              time: { value: 0 },
              forcePoint: { value: new THREE.Vector2(0.5, 0.5) },
              forceVector: { value: new THREE.Vector2(0, 0) },
              vortexStrength: { value: params.vortexStrength },
            },
          });
        }

        createRenderTarget() {
          return new THREE.WebGLRenderTarget(
            this.context.width,
            this.context.height,
            {
              format: THREE.RGBAFormat,
              type: THREE.FloatType,
            },
          );
        }

        createMesh(cx, cy, w, h) {
          const geometry = new THREE.PlaneGeometry(w, h);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.x = cx;
          mesh.position.y = cy;
          return mesh;
        }

        update(forcePoint, forceVector) {
          this.updateAdvection();
          this.updateDivergence();
          this.updatePressure();
          this.updateVelocity(forcePoint, forceVector);

          // パラメータを更新
          this.updateMaterial.uniforms.speed.value = params.speed;
          this.forceInitMaterial.uniforms.vortexStrength.value =
            params.vortexStrength;
        }

        updateAdvection() {
          this.context.renderer.setRenderTarget(this.advection);
          this.mainMesh.material = this.advectionMaterial;
          this.advectionMaterial.uniforms.tex = {
            value: this.velocity[this.velocityIndex].texture,
          };
          this.advectionMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        updateDivergence() {
          this.context.renderer.setRenderTarget(this.divergence);
          this.mainMesh.material = this.divergenceMaterial;
          this.divergenceMaterial.uniforms.tex = {
            value: this.advection.texture,
          };
          this.divergenceMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        updatePressure() {
          this.context.renderer.setRenderTarget(this.pressure[0]);
          this.context.renderer.clear();
          this.context.renderer.setRenderTarget(null);

          for (let i = 0; i < 4; i++) {
            let i0 = i % 2;
            let i1 = (i + 1) % 2;
            const prevPressure = this.pressure[i0];
            const nextPressure = this.pressure[i1];

            this.context.renderer.setRenderTarget(nextPressure);
            this.mainMesh.material = this.pressureMaterial;
            this.pressureMaterial.uniforms.tex = {
              value: prevPressure.texture,
            };
            this.pressureMaterial.uniforms.divergence = {
              value: this.divergence.texture,
            };
            this.pressureMaterial.uniforms.speed.value = params.speed;
            this.context.renderer.render(this.mainScene, this.context.camera);
            this.context.renderer.setRenderTarget(null);
          }
        }

        updateVelocity(forcePoint, forceVector) {
          const i1 = (this.velocityIndex + 1) % 2;
          const nextVelocity = this.velocity[i1];
          this.velocityIndex = i1;

          this.context.renderer.setRenderTarget(nextVelocity);
          this.mainMesh.material = this.updateMaterial;
          this.updateMaterial.uniforms.pressure = {
            value: this.pressure[1].texture,
          };
          this.updateMaterial.uniforms.advection = {
            value: this.advection.texture,
          };
          this.updateMaterial.uniforms.forcePoint.value = forcePoint;
          this.updateMaterial.uniforms.forceVector.value = forceVector;
          this.updateMaterial.uniforms.time.value = params.time;
          this.updateMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        draw() {
          this.mainMesh.material = this.renderMaterial;
          this.renderMaterial.uniforms.tex = {
            value: this.getVelocity().texture,
          };
          this.context.renderer.render(this.mainScene, this.context.camera);
        }

        getVelocity() {
          return this.velocity[this.velocityIndex];
        }
      }

      // Paint クラス
      class Paint {
        constructor(context) {
          this.context = context;
          this.speed = params.speed;
          this.initMaterial = this.createShaderMaterial(paintInitFrag);
          this.updateMaterial = this.createShaderMaterial(paintUpdateFrag);
          this.renderMaterial = this.createShaderMaterial(paintRenderFrag);
          this.paint = [this.createRenderTarget(), this.createRenderTarget()];

          this.mainScene = new THREE.Scene();
          this.mainMesh = this.createMesh(
            0,
            0,
            this.context.width,
            this.context.height,
          );
          this.mainScene.add(this.mainMesh);

          this.init();
        }

        init() {
          this.paintIndex = 0;
          this.context.renderer.setRenderTarget(this.paint[0]);
          this.mainMesh.material = this.initMaterial;
          this.initMaterial.uniforms.seed = { value: Math.random() * 100.0 };
          this.initMaterial.uniforms.time = { value: params.time };
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        createShaderMaterial(frag) {
          return new THREE.ShaderMaterial({
            vertexShader: vert,
            fragmentShader: frag,
            uniforms: {
              tex: { value: null },
              res: { value: [this.context.width, this.context.height] },
              speed: { value: this.speed },
              time: { value: 0 },
              colorIntensity: { value: params.colorIntensity },
            },
          });
        }

        createRenderTarget() {
          return new THREE.WebGLRenderTarget(
            this.context.width,
            this.context.height,
            {
              format: THREE.RGBAFormat,
              type: THREE.FloatType,
            },
          );
        }

        createMesh(cx, cy, w, h) {
          const geometry = new THREE.PlaneGeometry(w, h);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.x = cx;
          mesh.position.y = cy;
          return mesh;
        }

        update(velocity) {
          const i0 = this.paintIndex % 2;
          const i1 = (this.paintIndex + 1) % 2;
          const prevPaint = this.paint[i0];
          const nextPaint = this.paint[i1];
          this.paintIndex = i1;

          this.context.renderer.setRenderTarget(nextPaint);
          this.mainMesh.material = this.updateMaterial;
          this.updateMaterial.uniforms.tex = { value: prevPaint.texture };
          this.updateMaterial.uniforms.velocity = { value: velocity.texture };
          this.updateMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        draw() {
          this.mainMesh.material = this.renderMaterial;
          this.renderMaterial.uniforms.tex = { value: this.getPaint().texture };
          this.renderMaterial.uniforms.colorIntensity.value =
            params.colorIntensity;
          this.renderMaterial.uniforms.time.value = params.time;
          this.context.renderer.render(this.mainScene, this.context.camera);
        }

        getPaint() {
          return this.paint[this.paintIndex];
        }
      }

      // 初期化
      function init() {
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          preserveDrawingBuffer: true, // 画像保存のために必須
          alpha: false,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        canvas = renderer.domElement;
        document.body.appendChild(canvas);

        const fov = 65;
        const hFovRadian = (fov / 2 / 180) * Math.PI;
        const cz = window.innerHeight / 2 / Math.tan(hFovRadian);

        const camera = new THREE.PerspectiveCamera(
          fov,
          window.innerWidth / window.innerHeight,
          0.1,
          cz * 4,
        );
        camera.position.z = cz;

        const context = {
          renderer,
          camera,
          width: window.innerWidth,
          height: window.innerHeight,
        };

        fluid = new Fluid(context);
        paint = new Paint(context);

        // 自動力点の初期化
        for (let i = 0; i < 5; i++) {
          autoForcePoints.push({
            x: Math.random(),
            y: Math.random(),
            vx: (Math.random() - 0.5) * 0.01,
            vy: (Math.random() - 0.5) * 0.01,
            angle: Math.random() * Math.PI * 2,
            angleSpeed: (Math.random() - 0.5) * 0.1,
          });
        }
      }

      // アニメーションループ
      async function animate() {
        params.time += 0.01;

        // リセット間隔
        if (count % 640 == 0) {
          fluid.init();
          paint.init();
        }
        count++;

        // 自動的に力を加える
        if (count % params.autoSpeed === 0) {
          const point = autoForcePoints[count % autoForcePoints.length];

          // 力点を移動
          point.x += point.vx;
          point.y += point.vy;
          point.angle += point.angleSpeed;

          // 境界で反射
          if (point.x < 0 || point.x > 1) point.vx *= -1;
          if (point.y < 0 || point.y > 1) point.vy *= -1;
          point.x = Math.max(0, Math.min(1, point.x));
          point.y = Math.max(0, Math.min(1, point.y));

          // 力のベクトルを計算
          const forceX = Math.cos(point.angle) * 0.5;
          const forceY = Math.sin(point.angle) * 0.5;

          fluid.update(
            new THREE.Vector2(point.x, point.y),
            new THREE.Vector2(forceX, forceY),
          );
        } else {
          fluid.update(new THREE.Vector2(0.5, 0.5), new THREE.Vector2(0, 0));
        }

        // クリアしてから描画
        fluid.context.renderer.clear();
        fluid.draw();
        paint.update(fluid.getVelocity());
        paint.draw();

        // 明示的にcanvasの内容を更新
        fluid.context.renderer.domElement.style.display = 'block';

        requestAnimationFrame(animate);
      }

      // UIコントロール
      const controls = {
        speed: document.getElementById('speed'),
        vortex: document.getElementById('vortex'),
        colorIntensity: document.getElementById('color-intensity'),
        autoSpeed: document.getElementById('auto-speed'),
      };

      controls.speed.addEventListener('input', (e) => {
        params.speed = parseFloat(e.target.value);
        document.getElementById('speed-value').textContent = e.target.value;
      });

      controls.vortex.addEventListener('input', (e) => {
        params.vortexStrength = parseFloat(e.target.value);
        document.getElementById('vortex-value').textContent = e.target.value;
      });

      controls.colorIntensity.addEventListener('input', (e) => {
        params.colorIntensity = parseFloat(e.target.value);
        document.getElementById('color-intensity-value').textContent =
          e.target.value;
      });

      controls.autoSpeed.addEventListener('input', (e) => {
        params.autoSpeed = parseInt(e.target.value);
        document.getElementById('auto-speed-value').textContent =
          e.target.value;
      });

      // リセットボタン
      document.getElementById('reset').addEventListener('click', () => {
        count = 0;
        fluid.init();
        paint.init();
      });

      // 画像保存機能
      function captureImage() {
        // レンダリングを確実に完了させる
        if (fluid && paint) {
          fluid.draw();
          paint.draw();
        }

        // canvasから画像データを取得
        canvas.toBlob((blob) => {
          if (blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `fluid-sim-threejs-${Date.now()}.png`;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          } else {
            // Blobが取得できない場合は従来の方法を試す
            try {
              const dataURL = canvas.toDataURL('image/png');
              const link = document.createElement('a');
              link.download = `fluid-sim-threejs-${Date.now()}.png`;
              link.href = dataURL;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            } catch (e) {
              console.error('画像保存エラー:', e);
              alert(
                '画像の保存に失敗しました。ブラウザの設定を確認してください。',
              );
            }
          }
        }, 'image/png');
      }

      document.getElementById('capture').addEventListener('click', () => {
        // 次のフレームで保存を実行（レンダリング完了を待つ）
        requestAnimationFrame(() => {
          captureImage();
        });
      });

      // キーボードショートカット
      document.addEventListener('keydown', (e) => {
        if (e.key === 's' || e.key === 'S') {
          e.preventDefault(); // ブラウザのデフォルト動作を防ぐ
          requestAnimationFrame(() => {
            captureImage();
          });
        }
      });

      // リサイズ対応
      window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;

        if (fluid && paint) {
          // 再初期化が必要
          init();
        }
      });

      // 開始
      init();
      animate();
    </script>
  </body>
</html>
