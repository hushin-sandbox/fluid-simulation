<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Generative Circle Art - Three.js</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #fff;
        font-family: 'Courier New', monospace;
      }

      canvas {
        display: block;
      }

      .controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 10px;
        color: #00e5ff;
        border: 2px solid #00e5ff;
        box-shadow: 0 0 20px rgba(0, 229, 255, 0.5);
        width: 280px;
      }

      .controls h3 {
        margin: 0 0 15px 0;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 0 10px currentColor;
      }

      .control-group {
        margin: 10px 0;
      }

      .control-group label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        color: #fff200;
        text-shadow: 0 0 5px currentColor;
      }

      .control-group input[type='range'] {
        width: 100%;
        -webkit-appearance: none;
        height: 5px;
        background: linear-gradient(90deg, #ff2ed1, #00e5ff, #00ff8c);
        outline: none;
        border-radius: 5px;
      }

      .control-group input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 15px;
        height: 15px;
        background: #fff200;
        cursor: pointer;
        border-radius: 50%;
        box-shadow: 0 0 10px #fff200;
      }

      button {
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        background: linear-gradient(45deg, #ff2ed1, #3f48ff);
        border: none;
        color: white;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s;
        font-family: 'Courier New', monospace;
      }

      button:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(255, 46, 209, 0.5);
      }

      .info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #666;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #ccc;
      }

      .value-display {
        color: #ff8a00;
        float: right;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <h3>アートパラメータ</h3>

      <div class="control-group">
        <label
          >流体速度 <span class="value-display" id="speed-value">2</span></label
        >
        <input type="range" id="speed" min="0.5" max="8" step="0.5" value="2" />
      </div>

      <div class="control-group">
        <label
          >拡散強度
          <span class="value-display" id="diffusion-value">0.8</span></label
        >
        <input
          type="range"
          id="diffusion"
          min="0.1"
          max="2"
          step="0.1"
          value="0.8"
        />
      </div>

      <div class="control-group">
        <label
          >色強度
          <span class="value-display" id="color-intensity-value">2</span></label
        >
        <input
          type="range"
          id="color-intensity"
          min="0.5"
          max="4"
          step="0.1"
          value="2"
        />
      </div>

      <button id="reset">リセット</button>
      <button id="capture">画像を保存 (Sキー)</button>
      <div
        style="
          margin-top: 10px;
          font-size: 11px;
          color: #00ff8c;
          text-align: center;
        "
      >
        ※保存がうまくいかない場合は<br />右クリック→「画像を保存」でも可能
      </div>
    </div>

    <div class="info">
      中央の円から色が押し出されるgenerative art | Sキーで画像保存<br />
      <span style="font-size: 12px; opacity: 0.8"
        >色は1秒ごとにサイクル変化</span
      >
    </div>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

      let fluid,
        paint,
        count = 0,
        canvas;
      let params = {
        speed: 2,
        diffusion: 0.8,
        colorIntensity: 2,
        time: 0,
      };

      // カラーサイクル
      const colors = [
        { r: 0.867, g: 0.396, b: 0.251 }, // #DD6540
        { r: 0.569, g: 0.325, b: 0.525 }, // #915386
        { r: 0.004, g: 0.62, b: 0.592 }, // #019E97
        { r: 0.431, g: 0.616, b: 0.333 }, // #6E9D55
      ];

      // ノイズ関数を含むシェーダーコード
      const noise = `
        #define NORMALIZE_GRADIENTS
        #undef USE_CIRCLE
        #define COLLAPSE_SORTNET

        float permute(float x0,vec3 p) {
            float x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }
        vec2 permute(vec2 x0,vec3 p) {
            vec2 x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }
        vec3 permute(vec3 x0,vec3 p) {
            vec3 x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }
        vec4 permute(vec4 x0,vec3 p) {
            vec4 x1 = mod(x0 * p.y, p.x);
            return floor(  mod( (x1 + p.z) *x0, p.x ));
        }

        const vec4 pParam = vec4( 17.0*17.0, 34.0, 1.0, 7.0);

        float taylorInvSqrt(float r) {
            return ( 0.83666002653408 + 0.7*0.85373472095314 - 0.85373472095314 * r );
        }

        float simplexNoise2(vec2 v) {
            const vec2 C = vec2(0.211324865405187134, 0.366025403784438597);
            const vec3 D = vec3( 0., 0.5, 2.0) * 3.14159265358979312;
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1  =  (x0.x > x0.y) ? vec2(1.,0.) : vec2(0.,1.) ;
            vec2 x1 = x0 - i1 + 1. * C.xx ;
            vec2 x2 = x0 - 1. + 2. * C.xx ;
            i = mod(i, pParam.x);
            vec3 p = permute( permute(
                i.y + vec3(0., i1.y, 1. ), pParam.xyz)
                + i.x + vec3(0., i1.x, 1. ), pParam.xyz);
            vec3 x = fract(p / pParam.w) ;
            vec3 h = 0.5 - abs(x) ;
            vec3 sx = vec3(lessThan(x,D.xxx)) *2. -1.;
            vec3 sh = vec3(lessThan(h,D.xxx));
            vec3 a0 = x + sx*sh;
            vec2 p0 = vec2(a0.x,h.x);
            vec2 p1 = vec2(a0.y,h.y);
            vec2 p2 = vec2(a0.z,h.z);
            p0 *= taylorInvSqrt(dot(p0,p0));
            p1 *= taylorInvSqrt(dot(p1,p1));
            p2 *= taylorInvSqrt(dot(p2,p2));
            vec3 g = 2.0 * vec3( dot(p0, x0), dot(p1, x1), dot(p2, x2) );
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.);
            m = m*m ;
            return 1.66666* 70.*dot(m*m, g);
        }

        float v3n1(vec3 v) {
            return simplexNoise2(v.xy);
        }`;

      const vert = `
        varying vec2 vUv;
        varying vec3 vNormal;

        void main() {
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_Position = projectionMatrix * mvPosition;
        }`;

      const advectionFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        void main() {
            vec2 vel = texture2D(tex, wrap(vUv)).xy;
            vec4 color = texture2D(tex, wrap(vUv + vel * speed / res));
            gl_FragColor = color;
        }`;

      const divergenceFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        vec2 u(vec2 coord) {
            return texture2D(tex, wrap(coord)).xy;
        }

        void main() {
            float rho = 1.0;
            float deltaT = 1.0 / 60.0;
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;

            float divergence =
                (px.x * rho / deltaT) *
                (
                    (u(vUv - px.xz).x -
                    u(vUv + px.xz).x)
                    +
                    (u(vUv - px.zy).y -
                    u(vUv + px.zy).y)
                );

            gl_FragColor = vec4(divergence , 0.0, 0.0, 1.0);
        }`;

      const forceInitFrag =
        noise +
        `
        uniform float seed;
        uniform vec2 res;
        uniform float time;
        uniform float diffusion;
        varying vec2 vUv;
        varying vec3 vNormal;

        void main() {
            // 中央の円から放射状に流れを生成
            vec2 center = vec2(0.5, 0.5);
            vec2 toCenter = vUv - center;
            float dist = length(toCenter);

            // 円の半径（画面の10%、つまり直径20%）
            float radius = 0.1;

            vec2 force = vec2(0.0);

            if (dist < radius) {
                // 円の内部から外側への放射状の力
                float strength = (radius - dist) / radius;
                force = normalize(toCenter) * strength * diffusion * 3.0;
            }

            // 軽いノイズを追加してより自然な流れに
            float n0 = seed + 12.3 + time * 0.005;
            float n1 = seed + 123.4 + time * 0.007;

            vec2 v0 = vUv * res / 500.0;
            vec2 v1 = vUv * res / 700.0;

            float nr = v3n1(vec3(v0, n0)) * 0.1;
            float ng = v3n1(vec3(v1, n1)) * 0.1;

            force += vec2(nr, ng);

            gl_FragColor = vec4(force, 0.0, 1.0);
        }`;

      const forceRenderFrag = `
        varying vec2 vUv;
        varying vec3 vNormal;
        uniform sampler2D tex;

        void main( void ) {
            vec4 vel = texture2D(tex, vUv);
            float magnitude = length(vel.xy);
            vec3 color = vec3(magnitude * 2.0, magnitude * 0.5, magnitude);
            gl_FragColor = vec4(color, 1.0);
        }`;

      const forceUpdateFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D pressure;
        uniform sampler2D advection;
        uniform vec2 forcePoint;
        uniform vec2 forceVector;
        uniform float time;

        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        float p(vec2 coord) {
            return texture2D(pressure, wrap(coord)).x;
        }

        void main() {
            float deltaT = 1.0 / 60.0;
            float rho = 0.999;
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;
            vec4 u_a = texture2D(advection, vUv);

            float diff_p_x = (p(vUv + px.xz) - p(vUv - px.xz));
            float u_x = u_a.x - deltaT / (2.0 * rho * px.x) * diff_p_x;
            float diff_p_y = (p(vUv + px.zy) - p(vUv - px.zy));
            float u_y = u_a.y - deltaT / (2.0 * rho * px.y) * diff_p_y;

            // 外部からの力を追加
            float dist = distance(vUv, forcePoint);
            float influence = exp(-dist * dist * 200.0);
            u_x += forceVector.x * influence;
            u_y += forceVector.y * influence;

            u_a = vec4(vec2(u_x, u_y) * 0.98, 0.0, 1.0);

            gl_FragColor = u_a;
        }`;

      const pressureFrag =
        noise +
        `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        uniform sampler2D divergence;

        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        float d(vec2 coord) {
            return texture2D(divergence, wrap(coord)).x;
        }

        float p(vec2 coord) {
            return texture2D(tex, wrap(coord)).x;
        }

        void main() {
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;

            float pressure = 0.25 * (d(vUv)
            + p(vUv + px.xz)
            + p(vUv - px.xz)
            + p(vUv + px.zy)
            + p(vUv - px.zy)
            );

            gl_FragColor = vec4(vec3(pressure), 1.0);
        }`;

      // 白背景から円の色を拡散させるペイントシェーダー
      const paintInitFrag = `
        uniform float seed;
        uniform vec2 res;
        uniform float time;
        uniform vec3 circleColor;
        varying vec2 vUv;
        varying vec3 vNormal;

        void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(vUv, center);
            float radius = 0.1; // 円の半径（画面の10%、直径20%）

            vec4 color;

            if (dist <= radius) {
                // 円の内部は指定された色
                float fade = 1.0 - (dist / radius) * 0.3; // 中心ほど濃く
                color = vec4(circleColor * fade, 1.0);
            } else {
                // 円の外部は白
                color = vec4(1.0, 1.0, 1.0, 1.0);
            }

            gl_FragColor = color;
        }`;

      const paintRenderFrag = `
        varying vec2 vUv;
        varying vec3 vNormal;
        uniform vec2 res;
        uniform sampler2D tex;
        uniform float colorIntensity;
        uniform float time;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        void main( void ) {
            vec4 color = texture2D(tex, vUv);

            // 色の強度を調整
            color.rgb *= colorIntensity;

            // 少しコントラストを追加
            color.rgb = pow(color.rgb, vec3(1.2));

            gl_FragColor = vec4(color.rgb, 1.0);
        }`;

      const paintUpdateFrag = `
        uniform vec2 res;
        uniform float speed;
        uniform sampler2D tex;
        uniform sampler2D velocity;

        varying vec2 vUv;
        varying vec3 vNormal;

        vec2 wrap(vec2 v) {
            return vec2(fract(v.x), fract(v.y));
        }

        void main() {
            vec3 px = vec3(1.0 / res.x, 1.0 / res.y, 0.0) * speed;
            vec4 v = texture2D(velocity, vUv);
            vec4 p = texture2D(tex, wrap(vUv + px.xy * v.xy));

            // 色の減衰を抑制（白に戻りにくくする）
            p.rgb *= 0.9995;

            gl_FragColor = p;
        }`;

      // Fluid クラス
      class Fluid {
        constructor(context) {
          this.context = context;
          this.speed = params.speed;
          this.forceInitMaterial = this.createShaderMaterial(forceInitFrag);
          this.divergenceMaterial = this.createShaderMaterial(divergenceFrag);
          this.advectionMaterial = this.createShaderMaterial(advectionFrag);
          this.pressureMaterial = this.createShaderMaterial(pressureFrag);
          this.updateMaterial = this.createShaderMaterial(forceUpdateFrag);
          this.renderMaterial = this.createShaderMaterial(forceRenderFrag);
          this.velocity = [
            this.createRenderTarget(),
            this.createRenderTarget(),
          ];
          this.pressure = [
            this.createRenderTarget(),
            this.createRenderTarget(),
          ];
          this.divergence = this.createRenderTarget();
          this.advection = this.createRenderTarget();
          this.blank = this.createRenderTarget();

          this.mainScene = new THREE.Scene();
          this.mainMesh = this.createMesh(
            0,
            0,
            this.context.width,
            this.context.height,
          );
          this.mainScene.add(this.mainMesh);

          this.init();
        }

        init() {
          this.velocityIndex = 0;
          this.context.renderer.setRenderTarget(this.velocity[0]);
          this.mainMesh.material = this.forceInitMaterial;
          this.forceInitMaterial.uniforms.seed = {
            value: Math.random() * 100.0,
          };
          this.forceInitMaterial.uniforms.time = { value: params.time };
          this.forceInitMaterial.uniforms.diffusion = {
            value: params.diffusion,
          };
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        createShaderMaterial(frag) {
          return new THREE.ShaderMaterial({
            vertexShader: vert,
            fragmentShader: frag,
            uniforms: {
              tex: { value: null },
              res: { value: [this.context.width, this.context.height] },
              speed: { value: this.speed },
              time: { value: 0 },
              forcePoint: { value: new THREE.Vector2(0.5, 0.5) },
              forceVector: { value: new THREE.Vector2(0, 0) },
              diffusion: { value: params.diffusion },
            },
          });
        }

        createRenderTarget() {
          return new THREE.WebGLRenderTarget(
            this.context.width,
            this.context.height,
            {
              format: THREE.RGBAFormat,
              type: THREE.FloatType,
            },
          );
        }

        createMesh(cx, cy, w, h) {
          const geometry = new THREE.PlaneGeometry(w, h);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.x = cx;
          mesh.position.y = cy;
          return mesh;
        }

        update(forcePoint, forceVector) {
          this.updateAdvection();
          this.updateDivergence();
          this.updatePressure();
          this.updateVelocity(forcePoint, forceVector);

          // パラメータを更新
          this.updateMaterial.uniforms.speed.value = params.speed;
          this.forceInitMaterial.uniforms.diffusion.value = params.diffusion;
        }

        updateAdvection() {
          this.context.renderer.setRenderTarget(this.advection);
          this.mainMesh.material = this.advectionMaterial;
          this.advectionMaterial.uniforms.tex = {
            value: this.velocity[this.velocityIndex].texture,
          };
          this.advectionMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        updateDivergence() {
          this.context.renderer.setRenderTarget(this.divergence);
          this.mainMesh.material = this.divergenceMaterial;
          this.divergenceMaterial.uniforms.tex = {
            value: this.advection.texture,
          };
          this.divergenceMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        updatePressure() {
          this.context.renderer.setRenderTarget(this.pressure[0]);
          this.context.renderer.clear();
          this.context.renderer.setRenderTarget(null);

          for (let i = 0; i < 4; i++) {
            let i0 = i % 2;
            let i1 = (i + 1) % 2;
            const prevPressure = this.pressure[i0];
            const nextPressure = this.pressure[i1];

            this.context.renderer.setRenderTarget(nextPressure);
            this.mainMesh.material = this.pressureMaterial;
            this.pressureMaterial.uniforms.tex = {
              value: prevPressure.texture,
            };
            this.pressureMaterial.uniforms.divergence = {
              value: this.divergence.texture,
            };
            this.pressureMaterial.uniforms.speed.value = params.speed;
            this.context.renderer.render(this.mainScene, this.context.camera);
            this.context.renderer.setRenderTarget(null);
          }
        }

        updateVelocity(forcePoint, forceVector) {
          const i1 = (this.velocityIndex + 1) % 2;
          const nextVelocity = this.velocity[i1];
          this.velocityIndex = i1;

          this.context.renderer.setRenderTarget(nextVelocity);
          this.mainMesh.material = this.updateMaterial;
          this.updateMaterial.uniforms.pressure = {
            value: this.pressure[1].texture,
          };
          this.updateMaterial.uniforms.advection = {
            value: this.advection.texture,
          };
          this.updateMaterial.uniforms.forcePoint.value = forcePoint;
          this.updateMaterial.uniforms.forceVector.value = forceVector;
          this.updateMaterial.uniforms.time.value = params.time;
          this.updateMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        draw() {
          this.mainMesh.material = this.renderMaterial;
          this.renderMaterial.uniforms.tex = {
            value: this.getVelocity().texture,
          };
          this.context.renderer.render(this.mainScene, this.context.camera);
        }

        getVelocity() {
          return this.velocity[this.velocityIndex];
        }
      }

      // Paint クラス
      class Paint {
        constructor(context) {
          this.context = context;
          this.speed = params.speed;
          this.initMaterial = this.createShaderMaterial(paintInitFrag);
          this.updateMaterial = this.createShaderMaterial(paintUpdateFrag);
          this.renderMaterial = this.createShaderMaterial(paintRenderFrag);
          this.paint = [this.createRenderTarget(), this.createRenderTarget()];

          this.mainScene = new THREE.Scene();
          this.mainMesh = this.createMesh(
            0,
            0,
            this.context.width,
            this.context.height,
          );
          this.mainScene.add(this.mainMesh);

          this.init();
        }

        init() {
          this.paintIndex = 0;
          this.context.renderer.setRenderTarget(this.paint[0]);
          this.mainMesh.material = this.initMaterial;
          this.initMaterial.uniforms.seed = { value: Math.random() * 100.0 };
          this.initMaterial.uniforms.time = { value: params.time };

          // 初期色を設定（最初の色）
          const currentColor = colors[0];
          this.initMaterial.uniforms.circleColor = {
            value: new THREE.Vector3(
              currentColor.r,
              currentColor.g,
              currentColor.b,
            ),
          };

          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        createShaderMaterial(frag) {
          return new THREE.ShaderMaterial({
            vertexShader: vert,
            fragmentShader: frag,
            uniforms: {
              tex: { value: null },
              res: { value: [this.context.width, this.context.height] },
              speed: { value: this.speed },
              time: { value: 0 },
              colorIntensity: { value: params.colorIntensity },
              circleColor: { value: new THREE.Vector3(1, 1, 1) },
            },
          });
        }

        createRenderTarget() {
          return new THREE.WebGLRenderTarget(
            this.context.width,
            this.context.height,
            {
              format: THREE.RGBAFormat,
              type: THREE.FloatType,
            },
          );
        }

        createMesh(cx, cy, w, h) {
          const geometry = new THREE.PlaneGeometry(w, h);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.x = cx;
          mesh.position.y = cy;
          return mesh;
        }

        update(velocity) {
          const i0 = this.paintIndex % 2;
          const i1 = (this.paintIndex + 1) % 2;
          const prevPaint = this.paint[i0];
          const nextPaint = this.paint[i1];
          this.paintIndex = i1;

          this.context.renderer.setRenderTarget(nextPaint);
          this.mainMesh.material = this.updateMaterial;
          this.updateMaterial.uniforms.tex = { value: prevPaint.texture };
          this.updateMaterial.uniforms.velocity = { value: velocity.texture };
          this.updateMaterial.uniforms.speed.value = params.speed;
          this.context.renderer.render(this.mainScene, this.context.camera);
          this.context.renderer.setRenderTarget(null);
        }

        draw() {
          this.mainMesh.material = this.renderMaterial;
          this.renderMaterial.uniforms.tex = { value: this.getPaint().texture };
          this.renderMaterial.uniforms.colorIntensity.value =
            params.colorIntensity;
          this.renderMaterial.uniforms.time.value = params.time;
          this.context.renderer.render(this.mainScene, this.context.camera);
        }

        getPaint() {
          return this.paint[this.paintIndex];
        }

        // 色を更新するメソッド
        updateCircleColor() {
          const colorIndex = Math.floor(params.time * 0.5) % colors.length; // 1秒ごと（time * 0.5で2秒に1回の変化を1秒に1回に）
          const currentColor = colors[colorIndex];

          this.initMaterial.uniforms.circleColor.value.set(
            currentColor.r,
            currentColor.g,
            currentColor.b,
          );
        }
      }

      // 初期化
      function init() {
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          preserveDrawingBuffer: true, // 画像保存のために必須
          alpha: false,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff, 1.0); // 白い背景
        canvas = renderer.domElement;
        document.body.appendChild(canvas);

        const fov = 65;
        const hFovRadian = (fov / 2 / 180) * Math.PI;
        const cz = window.innerHeight / 2 / Math.tan(hFovRadian);

        const camera = new THREE.PerspectiveCamera(
          fov,
          window.innerWidth / window.innerHeight,
          0.1,
          cz * 4,
        );
        camera.position.z = cz;

        const context = {
          renderer,
          camera,
          width: window.innerWidth,
          height: window.innerHeight,
        };

        fluid = new Fluid(context);
        paint = new Paint(context);
      }

      // アニメーションループ
      async function animate() {
        params.time += 0.02;

        // 色のサイクル更新
        paint.updateCircleColor();

        // 定期的に円から新しい色を注入
        if (count % 30 === 0) {
          // 円の周囲の複数の点から色を押し出す
          const angleStep = (Math.PI * 2) / 8;
          for (let i = 0; i < 8; i++) {
            const angle = i * angleStep + params.time * 0.1;
            const radius = 0.08;
            const x = 0.5 + Math.cos(angle) * radius;
            const y = 0.5 + Math.sin(angle) * radius;

            const forceX = Math.cos(angle) * 0.3;
            const forceY = Math.sin(angle) * 0.3;

            fluid.update(
              new THREE.Vector2(x, y),
              new THREE.Vector2(forceX, forceY),
            );
          }
        } else {
          fluid.update(new THREE.Vector2(0.5, 0.5), new THREE.Vector2(0, 0));
        }

        count++;

        // リセット間隔を長くする
        if (count % 1200 == 0) {
          fluid.init();
          paint.init();
        }

        // クリアしてから描画
        fluid.context.renderer.clear();
        paint.update(fluid.getVelocity());
        paint.draw();

        requestAnimationFrame(animate);
      }

      // UIコントロール
      const controls = {
        speed: document.getElementById('speed'),
        diffusion: document.getElementById('diffusion'),
        colorIntensity: document.getElementById('color-intensity'),
      };

      controls.speed.addEventListener('input', (e) => {
        params.speed = parseFloat(e.target.value);
        document.getElementById('speed-value').textContent = e.target.value;
      });

      controls.diffusion.addEventListener('input', (e) => {
        params.diffusion = parseFloat(e.target.value);
        document.getElementById('diffusion-value').textContent = e.target.value;
      });

      controls.colorIntensity.addEventListener('input', (e) => {
        params.colorIntensity = parseFloat(e.target.value);
        document.getElementById('color-intensity-value').textContent =
          e.target.value;
      });

      // リセットボタン
      document.getElementById('reset').addEventListener('click', () => {
        count = 0;
        params.time = 0;
        fluid.init();
        paint.init();
      });

      // 画像保存機能
      function captureImage() {
        // レンダリングを確実に完了させる
        if (fluid && paint) {
          paint.draw();
        }

        // canvasから画像データを取得
        canvas.toBlob((blob) => {
          if (blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `circle-art-${Date.now()}.png`;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          } else {
            // Blobが取得できない場合は従来の方法を試す
            try {
              const dataURL = canvas.toDataURL('image/png');
              const link = document.createElement('a');
              link.download = `circle-art-${Date.now()}.png`;
              link.href = dataURL;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            } catch (e) {
              console.error('画像保存エラー:', e);
              alert(
                '画像の保存に失敗しました。ブラウザの設定を確認してください。',
              );
            }
          }
        }, 'image/png');
      }

      document.getElementById('capture').addEventListener('click', () => {
        // 次のフレームで保存を実行（レンダリング完了を待つ）
        requestAnimationFrame(() => {
          captureImage();
        });
      });

      // キーボードショートカット
      document.addEventListener('keydown', (e) => {
        if (e.key === 's' || e.key === 'S') {
          e.preventDefault(); // ブラウザのデフォルト動作を防ぐ
          requestAnimationFrame(() => {
            captureImage();
          });
        }
      });

      // リサイズ対応
      window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;

        if (fluid && paint) {
          // 再初期化が必要
          init();
        }
      });

      // 開始
      init();
      animate();
    </script>
  </body>
</html>
