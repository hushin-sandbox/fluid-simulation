<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Fluid Simulation Generative Art</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Setup
      const width = window.innerWidth;
      const height = window.innerHeight;
      const aspect = width / height;
      const simRes = 512; // Simulation resolution (square for simplicity)

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(width, height);
      document.body.appendChild(renderer.domElement);

      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const quad = new THREE.PlaneBufferGeometry(2, 2);

      // Scenes
      const simScene = new THREE.Scene();
      const displayScene = new THREE.Scene();

      const simMesh = new THREE.Mesh(quad);
      simScene.add(simMesh);

      const displayMesh = new THREE.Mesh(quad);
      displayScene.add(displayMesh);

      // Helper functions
      function createRenderTarget() {
        return new THREE.WebGLRenderTarget(simRes, simRes, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBAFormat,
          type: THREE.FloatType,
        });
      }

      // Buffers
      let velocity1 = createRenderTarget();
      let velocity2 = createRenderTarget();
      let density1 = createRenderTarget();
      let density2 = createRenderTarget();
      let pressure1 = createRenderTarget();
      let pressure2 = createRenderTarget();
      let divergence = createRenderTarget();

      // Shaders
      const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

      // Simplex noise
      const simplexNoise = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                    -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                    dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
        `;

      // Initial velocity shader (random flow)
      const initVelocityShader = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: `
                varying vec2 vUv;
                ${simplexNoise}
                void main() {
                    float n1 = snoise(vUv * 10.0);
                    float n2 = snoise(vUv * 10.0 + vec2(5.0));
                    vec2 vel = vec2(n1, n2) * 0.05; // Small random velocity
                    gl_FragColor = vec4(vel, 0.0, 0.0);
                }
            `,
        uniforms: {},
      });

      // Initial density (black)
      const initDensityShader = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: `
                varying vec2 vUv;
                void main() {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                }
            `,
        uniforms: {},
      });

      // Advection shader with dissipation
      const advectionFragment = `
            uniform sampler2D uTexture;
            uniform sampler2D uVelocity;
            uniform vec2 uResolution;
            uniform float uDt;
            uniform float uDissipation;
            varying vec2 vUv;

            vec4 bilerp(sampler2D tex, vec2 uv) {
                vec2 st = uv * uResolution - 0.5;
                vec2 i = floor(st);
                vec2 f = fract(st);
                vec4 a = texture2D(tex, (i + vec2(0.5, 0.5)) / uResolution);
                vec4 b = texture2D(tex, (i + vec2(1.5, 0.5)) / uResolution);
                vec4 c = texture2D(tex, (i + vec2(0.5, 1.5)) / uResolution);
                vec4 d = texture2D(tex, (i + vec2(1.5, 1.5)) / uResolution);
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            void main() {
                vec2 vel = texture2D(uVelocity, vUv).xy;
                vec2 pos = vUv - vel * uDt;
                gl_FragColor = bilerp(uTexture, pos) * uDissipation;
            }
        `;
      const advectionMaterial = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: advectionFragment,
        uniforms: {
          uTexture: { value: null },
          uVelocity: { value: null },
          uResolution: { value: new THREE.Vector2(simRes, simRes) },
          uDt: { value: 0.016 },
          uDissipation: { value: 1.0 },
        },
      });

      // Divergence shader
      const divergenceFragment = `
            uniform sampler2D uVelocity;
            uniform vec2 uTexelSize;
            varying vec2 vUv;
            void main() {
                float L = texture2D(uVelocity, vUv - vec2(uTexelSize.x, 0.0)).x;
                float R = texture2D(uVelocity, vUv + vec2(uTexelSize.x, 0.0)).x;
                float B = texture2D(uVelocity, vUv - vec2(0.0, uTexelSize.y)).y;
                float T = texture2D(uVelocity, vUv + vec2(0.0, uTexelSize.y)).y;
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `;
      const divergenceMaterial = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: divergenceFragment,
        uniforms: {
          uVelocity: { value: null },
          uTexelSize: { value: new THREE.Vector2(1 / simRes, 1 / simRes) },
        },
      });

      // Jacobi pressure shader
      const pressureFragment = `
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;
            uniform vec2 uTexelSize;
            varying vec2 vUv;
            void main() {
                float L = texture2D(uPressure, vUv - vec2(uTexelSize.x, 0.0)).x;
                float R = texture2D(uPressure, vUv + vec2(uTexelSize.x, 0.0)).x;
                float B = texture2D(uPressure, vUv - vec2(0.0, uTexelSize.y)).x;
                float T = texture2D(uPressure, vUv + vec2(0.0, uTexelSize.y)).x;
                float div = texture2D(uDivergence, vUv).x;
                float p = (L + R + B + T - div) * 0.25;
                gl_FragColor = vec4(p, 0.0, 0.0, 1.0);
            }
        `;
      const pressureMaterial = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: pressureFragment,
        uniforms: {
          uPressure: { value: null },
          uDivergence: { value: null },
          uTexelSize: { value: new THREE.Vector2(1 / simRes, 1 / simRes) },
        },
      });

      // Gradient subtract shader
      const gradientSubtractFragment = `
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;
            uniform vec2 uTexelSize;
            varying vec2 vUv;
            void main() {
                float L = texture2D(uPressure, vUv - vec2(uTexelSize.x, 0.0)).x;
                float R = texture2D(uPressure, vUv + vec2(uTexelSize.x, 0.0)).x;
                float B = texture2D(uPressure, vUv - vec2(0.0, uTexelSize.y)).x;
                float T = texture2D(uPressure, vUv + vec2(0.0, uTexelSize.y)).x;
                vec2 vel = texture2D(uVelocity, vUv).xy;
                vel.x -= 0.5 * (R - L);
                vel.y -= 0.5 * (T - B);
                gl_FragColor = vec4(vel, 0.0, 1.0);
            }
        `;
      const gradientSubtractMaterial = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: gradientSubtractFragment,
        uniforms: {
          uPressure: { value: null },
          uVelocity: { value: null },
          uTexelSize: { value: new THREE.Vector2(1 / simRes, 1 / simRes) },
        },
      });

      // Splat shader for density (add color with stronger intensity)
      const splatDensityFragment = `
            uniform sampler2D uDensity;
            uniform vec3 uColor;
            uniform vec2 uCenter;
            uniform float uRadius;
            uniform float uAspect;
            varying vec2 vUv;
            void main() {
                vec4 current = texture2D(uDensity, vUv);
                vec2 p = vUv - uCenter;
                p.x *= uAspect;
                float d = length(p);
                if (d < uRadius) {
                    float a = exp(-d * d / (uRadius * uRadius)) * 1.0; // Increased intensity
                    current.rgb = mix(current.rgb, uColor, a);
                }
                gl_FragColor = current;
            }
        `;
      const splatDensityMaterial = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: splatDensityFragment,
        uniforms: {
          uDensity: { value: null },
          uColor: { value: new THREE.Vector3(1, 0, 0) },
          uCenter: { value: new THREE.Vector2(0.5, 0.5) },
          uRadius: { value: 0.1 },
          uAspect: { value: aspect },
        },
      });

      // Splat shader for velocity (radial push out with noise for flare-like effect, stronger strength)
      const splatVelocityFragment = `
            uniform sampler2D uVelocity;
            uniform vec2 uCenter;
            uniform float uRadius;
            uniform float uStrength;
            uniform float uAspect;
            uniform float uTime;
            varying vec2 vUv;
            ${simplexNoise}
            void main() {
                vec4 current = texture2D(uVelocity, vUv);
                vec2 dir = vUv - uCenter;
                dir.x *= uAspect;
                float d = length(dir);
                if (d < uRadius && d > 0.001) {
                    vec2 normDir = normalize(dir);
                    float angle = atan(normDir.y, normDir.x);
                    float noise = snoise(vec2(angle * 5.0, uTime * 0.5)) * 0.5 + 0.5; // Noise based on angle and time
                    float flareFactor = pow(noise, 2.0); // Amplify noise for flare bursts
                    vec2 addVel = normDir * uStrength * flareFactor * (1.0 - d / uRadius);
                    current.xy += addVel;
                }
                gl_FragColor = current;
            }
        `;
      const splatVelocityMaterial = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: splatVelocityFragment,
        uniforms: {
          uVelocity: { value: null },
          uCenter: { value: new THREE.Vector2(0.5, 0.5) },
          uRadius: { value: 0.1 },
          uStrength: { value: 0.1 }, // Increased strength for more spread
          uAspect: { value: aspect },
          uTime: { value: 0.0 },
        },
      });

      // Final render shader with black circle overlay
      const finalFragment = `
            uniform sampler2D uDensity;
            uniform float uAspect;
            uniform vec2 uCenter;
            uniform float uRadius;
            varying vec2 vUv;
            void main() {
                vec4 color = texture2D(uDensity, vUv);
                vec2 p = vUv - uCenter;
                p.x *= uAspect;
                float d = length(p);
                if (d < uRadius) {
                    color = vec4(0.0, 0.0, 0.0, 1.0);
                }
                gl_FragColor = color;
            }
        `;
      const finalMaterial = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader: finalFragment,
        uniforms: {
          uDensity: { value: null },
          uAspect: { value: aspect },
          uCenter: { value: new THREE.Vector2(0.5, 0.5) },
          uRadius: { value: 0.1 },
        },
      });
      displayMesh.material = finalMaterial;

      // Initialize buffers
      function initBuffers() {
        // Init velocity
        simMesh.material = initVelocityShader;
        renderer.setRenderTarget(velocity1);
        renderer.render(simScene, camera);
        velocity2.texture = velocity1.texture.clone();

        // Init density
        simMesh.material = initDensityShader;
        renderer.setRenderTarget(density1);
        renderer.render(simScene, camera);
        density2.texture = density1.texture.clone();

        // Init pressure to 0
        renderer.setRenderTarget(pressure1);
        renderer.clear();
        pressure2.texture = pressure1.texture.clone();
      }

      initBuffers();

      // Colors cycle
      const colors = [
        new THREE.Vector3(221 / 255, 101 / 255, 64 / 255), // #DD6540
        new THREE.Vector3(145 / 255, 83 / 255, 134 / 255), // #915386
        new THREE.Vector3(1 / 255, 158 / 255, 151 / 255), // #019E97
        new THREE.Vector3(110 / 255, 157 / 255, 85 / 255), // #6E9D55
      ];

      const clock = new THREE.Clock();
      let elapsed = 0;

      function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        elapsed += dt;

        // Update time for noise
        splatVelocityMaterial.uniforms.uTime.value = elapsed;

        // Get current color index
        const colorIndex = Math.floor(elapsed) % 4;
        const currentColor = colors[colorIndex];

        // Splat color to density
        splatDensityMaterial.uniforms.uDensity.value = density1.texture;
        splatDensityMaterial.uniforms.uColor.value = currentColor;
        simMesh.material = splatDensityMaterial;
        renderer.setRenderTarget(density2);
        renderer.render(simScene, camera);
        [density1, density2] = [density2, density1];

        // Splat radial velocity with flare noise
        splatVelocityMaterial.uniforms.uVelocity.value = velocity1.texture;
        simMesh.material = splatVelocityMaterial;
        renderer.setRenderTarget(velocity2);
        renderer.render(simScene, camera);
        [velocity1, velocity2] = [velocity2, velocity1];

        // Advect velocity with reduced dissipation for more fluid-like behavior
        advectionMaterial.uniforms.uTexture.value = velocity1.texture;
        advectionMaterial.uniforms.uVelocity.value = velocity1.texture;
        advectionMaterial.uniforms.uDt.value = dt * 1.5; // Scaled dt for faster spread
        advectionMaterial.uniforms.uDissipation.value = 0.995;
        simMesh.material = advectionMaterial;
        renderer.setRenderTarget(velocity2);
        renderer.render(simScene, camera);
        [velocity1, velocity2] = [velocity2, velocity1];

        // Compute divergence
        divergenceMaterial.uniforms.uVelocity.value = velocity1.texture;
        simMesh.material = divergenceMaterial;
        renderer.setRenderTarget(divergence);
        renderer.render(simScene, camera);

        // Compute pressure (increased iterations for better fluid stability)
        let currentPressure = pressure1;
        let nextPressure = pressure2;
        for (let i = 0; i < 40; i++) {
          // Increased to 40 for smoother fluid
          pressureMaterial.uniforms.uPressure.value = currentPressure.texture;
          pressureMaterial.uniforms.uDivergence.value = divergence.texture;
          simMesh.material = pressureMaterial;
          renderer.setRenderTarget(nextPressure);
          renderer.render(simScene, camera);
          [currentPressure, nextPressure] = [nextPressure, currentPressure];
        }
        pressure1 = currentPressure;

        // Subtract gradient
        gradientSubtractMaterial.uniforms.uPressure.value = pressure1.texture;
        gradientSubtractMaterial.uniforms.uVelocity.value = velocity1.texture;
        simMesh.material = gradientSubtractMaterial;
        renderer.setRenderTarget(velocity2);
        renderer.render(simScene, camera);
        [velocity1, velocity2] = [velocity2, velocity1];

        // Advect density with reduced dissipation to keep colors longer and scaled dt
        advectionMaterial.uniforms.uTexture.value = density1.texture;
        advectionMaterial.uniforms.uVelocity.value = velocity1.texture;
        advectionMaterial.uniforms.uDt.value = dt * 1.5; // Scaled dt for faster spread
        advectionMaterial.uniforms.uDissipation.value = 0.999; // Reduced dissipation
        simMesh.material = advectionMaterial;
        renderer.setRenderTarget(density2);
        renderer.render(simScene, camera);
        [density1, density2] = [density2, density1];

        // Render to screen with overlay
        finalMaterial.uniforms.uDensity.value = density1.texture;
        renderer.setRenderTarget(null);
        renderer.render(displayScene, camera);
      }

      animate();

      // Handle resize
      window.addEventListener('resize', () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const newAspect = w / h;
        renderer.setSize(w, h);
        finalMaterial.uniforms.uAspect.value = newAspect;
        splatDensityMaterial.uniforms.uAspect.value = newAspect;
        splatVelocityMaterial.uniforms.uAspect.value = newAspect;
      });
    </script>
  </body>
</html>
